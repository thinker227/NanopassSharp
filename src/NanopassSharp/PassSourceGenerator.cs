using System;
using System.Collections.Immutable;
using System.Linq;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using MoreLinq;
using Scriban;
using NanopassSharp.Functional;
using NanopassSharp.Models;

namespace NanopassSharp;

internal static class PassSourceGenerator {

	public readonly record struct ModifiedTypeResult(
		string Source, NamespacedTypeName TypeName);
	public static Result<ModifiedTypeResult> GetModifiedTypeSource(RecordDeclarationSyntax baseSyntax, INamedTypeSymbol baseType, PassModel pass, ModificationPassModel mod) {
		var typeName = GetNamespacedTypeName(pass, mod, baseType);

		var record = GetRootPassRecord(baseSyntax, baseType, pass, mod);

		var context = new {
			Namespace = typeName.Namespace,
			Root = record,
		};

		var template = GetTemplate();
		string source = template.Render(context);

		return new ModifiedTypeResult(source, GetNamespacedTypeName(pass, mod, baseType));
	}
	private static Template GetTemplate() {
		const string templateSource =
"""
// <auto-generated />

namespace {{ namespace }};

public sealed record {{ root.name }}(
{{- for param in root.parameters -}}
{{ param }}{{ if !for.last }}, {{ end }}
{{- end -}}
) {
	
	{{~ for prop in root.properties ~}}
	{{ prop }}
	{{~ end ~}}

	// Nested types
	
}

""";
		return Template.Parse(templateSource);
	}

	public readonly record struct NamespacedTypeName(string Name, string Namespace) {
		public string FullName { get; } = $"{Namespace}.{Name}";
	}
	public static NamespacedTypeName GetNamespacedTypeName(PassModel pass, ModificationPassModel mod, INamedTypeSymbol baseType) {
		string @namespace = baseType.GetFullNamespace();
		string typeName = GetTypeName(pass, mod);
		return new(typeName, @namespace);
	}
	public static string GetTypeName(PassModel pass, ModificationPassModel mod) =>
		mod.TypeName ?? pass.Name;

	private readonly record struct TypeMod(
		INamedTypeSymbol Type,
		ImmutableArray<ModificationModel> Add,
		ImmutableArray<ModificationModel> Remove
	);
	private static IReadOnlyDictionary<INamedTypeSymbol, TypeMod> GetTypeMods(INamedTypeSymbol baseType, ModificationPassModel mod) {
		var paths = GetTargetPaths(baseType);
		var mods = GetTargetedTypeMods(mod);
		return mods
			.Join(
				paths,
				m => m.Target,
				p => p.Target,
				(m, p) => new TypeMod(p.Type, m.Add, m.Remove)
			).ToDictionary<TypeMod, INamedTypeSymbol>(m => m.Type, SymbolEqualityComparer.Default);
	}
	private readonly record struct TargetedTypeMod(
		string Target,
		ImmutableArray<ModificationModel> Add,
		ImmutableArray<ModificationModel> Remove
	);
	private static IEnumerable<TargetedTypeMod> GetTargetedTypeMods(ModificationPassModel modPass) {
		var add = modPass.Add
			.GroupBy(a => a.Target);
		var remove = modPass.Remove
			.GroupBy(r => r.Target);

		return add.FullJoin(
			remove,
			m => m.Key,
			a => new TargetedTypeMod(a.Key, a.ToImmutableArray(), ImmutableArray<ModificationModel>.Empty),
			r => new TargetedTypeMod(r.Key, ImmutableArray<ModificationModel>.Empty, r.ToImmutableArray()),
			(a, r) => new TargetedTypeMod(a.Key, a.ToImmutableArray(), r.ToImmutableArray())
		).ToArray();
	}

	private readonly record struct TypeAndTargetPath(
		INamedTypeSymbol Type,
		string Target
	);
	private static IEnumerable<TypeAndTargetPath> GetTargetPaths(INamedTypeSymbol baseType) =>
		// For some god-forsaken reason, MoreLinq defines its own Prepend method
		// which conflicts with the Linq Prepend. Explicitly calling Enumerable.Prepend
		// avoids any ambiguity.
		Enumerable.Prepend(GetTargetPaths(baseType, ""), new(baseType, "this"));
	private static IEnumerable<TypeAndTargetPath> GetTargetPaths(INamedTypeSymbol type, string currentPath) =>
		type.GetTypeMembers()
			.SelectMany(t => GetTargetPaths(t, currentPath == "" ? t.Name : $"{currentPath}.{t.Name}"));

	private sealed record class PassRecord(
		string Name,
		List<string> Parameters,
		List<string> Properties,
		HashSet<PassRecord> Nested
	);
	private static PassRecord GetRootPassRecord(RecordDeclarationSyntax baseSyntax, INamedTypeSymbol baseType, PassModel pass, ModificationPassModel mod) {
		var mods = GetTypeMods(baseType, mod);
		var rootRecord = GetPassRecord(baseSyntax, baseType, mods);
		return rootRecord with {
			Name = GetTypeName(pass, mod)
		};
	}
	private static PassRecord GetPassRecord(RecordDeclarationSyntax baseSyntax, INamedTypeSymbol baseType, IReadOnlyDictionary<INamedTypeSymbol, TypeMod> mods) {
		string name = baseType.Name;

		var mod = mods.TryGetValue(baseType, out var m) ? m : (TypeMod?)null;
		var add = mod?.Add ?? ImmutableArray<ModificationModel>.Empty;
		var remove = mod?.Remove ?? ImmutableArray<ModificationModel>.Empty;
		
		var baseParams = baseSyntax.ParameterList is not null
			? baseSyntax.ParameterList.Parameters
				.Select(p => p.GetText().ToString())
			: Enumerable.Empty<string>();
		var modParams = add
			.Select(a => a.Parameter)
			.OfType<string>();
		var parameters = baseParams
			.Concat(modParams)
			.ToList();

		var baseProperties = baseSyntax.Members
			.OfType<PropertyDeclarationSyntax>()
			.Select(p => p.GetText().ToString());
		var modProperties = add
			.Select(a => a.Property)
			.OfType<string>();
		var properties = baseProperties
			.Concat(modProperties)
			.ToList();

		var nested = baseType.GetTypeMembers()
			.Where(t => t.IsRecord)
			.Select(t => GetPassRecord(
				(RecordDeclarationSyntax)t.DeclaringSyntaxReferences[0].GetSyntax(),
				t,
				mods
			));
		// MoreEnumerable.ToHashSet conflicts with Enumerable.ToHashSet :/
		var nestedHashSet = Enumerable.ToHashSet(nested);

		PassRecord record = new(name, parameters, properties, nestedHashSet);
		//ApplyRemovals(record, remove);

		return record;
	}
	
}
