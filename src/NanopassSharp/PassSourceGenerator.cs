using System.Linq;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Scriban;
using NanopassSharp.Functional;
using NanopassSharp.Models;
using System;
using System.Collections.Immutable;

namespace NanopassSharp;

internal static class PassSourceGenerator {

	public readonly record struct ModifiedTypeResult(
		string Source, NamespacedTypeName TypeName);
	public static Result<ModifiedTypeResult> GetModifiedTypeSource(RecordDeclarationSyntax baseSyntax, INamedTypeSymbol baseType, PassModel pass, ModificationPassModel mod) {
		var typeName = GetNamespacedTypeName(pass, mod, baseType);

		var context = new {
			Namespace = typeName.Namespace,
			TypeName = typeName.Name,
		};

		var template = GetTemplate();
		string source = template.Render(context);

		return new ModifiedTypeResult(source, GetNamespacedTypeName(pass, mod, baseType));
	}
	private static Template GetTemplate() {
		const string templateSource =
"""
// <auto-generated />

namespace {{ namespace }};

public sealed record {{ type_name }} {
	
	// Members and nested types
	
}

""";
		return Template.Parse(templateSource);
	}

	public readonly record struct NamespacedTypeName(string Name, string Namespace) {
		public string FullName { get; } = $"{Namespace}.{Name}";
	}
	public static NamespacedTypeName GetNamespacedTypeName(PassModel pass, ModificationPassModel mod, INamedTypeSymbol baseType) {
		string @namespace = baseType.GetFullNamespace();
		string typeName = GetTypeName(pass, mod);
		return new(typeName, @namespace);
	}
	public static string GetTypeName(PassModel pass, ModificationPassModel mod) =>
		mod.TypeName ?? pass.Name;

	private readonly record struct TypeMod(
		INamedTypeSymbol Type,
		ImmutableArray<ModificationModel> Add,
		ImmutableArray<ModificationModel> Remove
	);
	private static IReadOnlyDictionary<INamedTypeSymbol, TypeMod> GetTypeMods(INamedTypeSymbol baseType, IEnumerable<TargetedTypeMod> mods) {
		var paths = GetTargetPaths(baseType);
		return mods
			.Join(
				paths,
				m => m.Target,
				p => p.Target,
				(m, p) => new TypeMod(p.Type, m.Add, m.Remove)
			).ToDictionary<TypeMod, INamedTypeSymbol>(m => m.Type, SymbolEqualityComparer.Default);
	}
	private readonly record struct TargetedTypeMod(
		string Target,
		ImmutableArray<ModificationModel> Add,
		ImmutableArray<ModificationModel> Remove
	);
	private static IEnumerable<TargetedTypeMod> GetTargetedTypeMods(ModificationPassModel modPass) {
		var add = modPass.Add.GroupBy(m => m.Target);
		var remove = modPass.Remove.GroupBy(m => m.Target);
		return add.Join(
			remove,
			m => m.Key,
			m => m.Key,
			(a, r) => new TargetedTypeMod(a.Key, a.ToImmutableArray(), r.ToImmutableArray())
		).ToArray();
	}

	private readonly record struct TypeAndTargetPath(
		INamedTypeSymbol Type,
		string Target
	);
	private static IEnumerable<TypeAndTargetPath> GetTargetPaths(INamedTypeSymbol baseType) =>
		GetTargetPaths(baseType, "")
			.Prepend(new(baseType, "this"));
	private static IEnumerable<TypeAndTargetPath> GetTargetPaths(INamedTypeSymbol type, string currentPath) =>
		type.GetTypeMembers()
			.SelectMany(t => GetTargetPaths(t, currentPath == "" ? t.Name : $"{currentPath}.{t.Name}"));

	private sealed record PassRecord(
		string Name,
		List<string> Parameters,
		List<string> Properties,
		HashSet<PassRecord> Nested
	);
	private static PassRecord GetRootPassRecord(RecordDeclarationSyntax baseSyntax, INamedTypeSymbol baseType, PassModel pass, ModificationPassModel mod) {
		
	}
	private static PassRecord GetPassRecord(RecordDeclarationSyntax baseSyntax, INamedTypeSymbol baseType, ModificationPassModel mod) {
		string name = baseType.Name;
		
		var baseParams = baseSyntax.ParameterList is not null
			? baseSyntax.ParameterList.Parameters
				.Select(p => p.GetText().ToString())
			: Enumerable.Empty<string>();
		var modParams = mod.Add
			.Select(a => a.Parameter)
			.OfType<string>();
		var parameters = baseParams
			.Concat(modParams)
			.ToList();

		var baseProperties = baseSyntax.Members
			.OfType<PropertyDeclarationSyntax>()
			.Select(p => p.GetText().ToString());
		var modProperties = mod.Add
			.Select(a => a.Property)
			.OfType<string>();
		var properties = baseProperties
			.Concat(modProperties)
			.ToList();

		var nested = baseType.GetTypeMembers()
			.Where(t => t.IsRecord)
			.Select(t => GetPassRecord(
				(RecordDeclarationSyntax)t.DeclaringSyntaxReferences[0].GetSyntax(),
				t,
				mod
			))
			.ToHashSet();

		PassRecord record = new(name, parameters, properties, nested);

		var remove = mod.Remove
			.Where(r => ParseNestedTypePath(r.Target, baseType).Equals(baseType, SymbolEqualityComparer.Default));
		ApplyRemovals(record, mod.Remove);

		return new(name, parameters, properties, nested);
	}

	private static INamedTypeSymbol? ParseNestedTypePath(string target, INamedTypeSymbol sourceType) {
		string[] paths = target.Split('.');
		return GetNestedType(paths, sourceType);
	}
	private static INamedTypeSymbol? GetNestedType(ReadOnlySpan<string> paths, INamedTypeSymbol source) {
		if (paths.Length == 0) return source;

		string path = paths[0];
		var type = source.GetTypeMembers()
			.FirstOrDefault(t => t.Name == path);
		if (type is null) return null;
		return GetNestedType(paths[1..], type);
	}

}
